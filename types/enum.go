package bsgostuff_types

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"

	"github.com/jackc/pgx/v5/pgtype"
	"google.golang.org/protobuf/reflect/protoreflect"
)

// Enum implements a nullable generic enum type with three-state logic:
// - Set (with concrete value)
// - Explicitly set to null
// - Unset (not initialized)
//
// Supports both protobuf enums and standard Go enums with:
// - String parsing (case insensitive)
// - PostgreSQL text storage
// - Null handling consistent with other Settable types
//
// Type parameter T must be comparable and typically represents:
// - Protobuf enum types (generated by protoc)
// - Go iota-based enums
// - String-based enums
//
// Implements Settable[T, T, pgtype.Text] where:
// - T is the enum type
// - Proto representation is the same as native (T)
// - PostgreSQL storage uses pgtype.Text
type Enum[T comparable] struct {
	value T
	set   bool
	null  bool
}

type Enums[T comparable] = Slice[Enum[T]]

func NewEnums[T comparable](items []Enum[T]) Enums[T] {
	return Enums[T](Slice[Enum[T]]{items: items, set: true})
}

// Compile-time interface check
var _ Settable[any, any, pgtype.Text] = (*Enum[any])(nil)

// NewEnum creates an initialized enum value.
// Returns concrete type for method chaining.
func NewEnum[T comparable](value T) Enum[T] {
	return Enum[T]{value: value, set: true}
}

// Set assigns a value from supported types:
// - Native enum type (T): direct value
// - *T: nil pointer treated as null
// - string: parsed as enum value (case insensitive)
// - pgtype.Text: respects Valid flag
// - nil: explicit null
func (e *Enum[T]) Set(value any) error {
	e.set = true
	e.null = false
	var zero T
	e.value = zero

	switch v := value.(type) {
	case T:
		e.value = v
	case *T:
		if v == nil {
			e.null = true
		} else {
			e.value = *v
		}
	case string:
		parsed, err := parseEnumFromString[T](v)
		if err != nil {
			return fmt.Errorf("failed to parse enum: %w", err)
		}
		e.value = parsed
	case pgtype.Text:
		if !v.Valid {
			e.null = true
		} else {
			parsed, err := parseEnumFromString[T](v.String)
			if err != nil {
				return err
			}
			e.value = parsed
		}
	case nil:
		e.null = true
	default:
		return fmt.Errorf("unsupported type: %T", value)
	}
	return nil
}

// GetValue returns the underlying enum value.
// Returns zero value when unset or null.
func (e Enum[T]) GetValue() T {
	return e.value
}

// GetPtr returns a pointer to the enum value.
// Returns nil when unset or null.
func (e Enum[T]) GetPtr() *T {
	if !e.set || e.null {
		return nil
	}
	return &e.value
}

// IsSet indicates whether the value was explicitly set.
// Returns false for uninitialized zero values.
func (e Enum[T]) IsSet() bool {
	return e.set
}

// IsNull indicates whether the value was explicitly set to null.
// Returns false for unset values.
func (e Enum[T]) IsNull() bool {
	return e.null
}

// ToProto converts to protobuf representation.
// For protobuf enums, returns the enum value directly.
// Returns zero value when unset or null.
func (e Enum[T]) ToProto() T {
	if !e.set || e.null {
		var zero T
		return zero
	}
	return e.value
}

// ToPgx converts to pgtype.Text for PostgreSQL integration.
// Sets Valid flag according to null/unset state.
// Stores string representation of the enum value.
func (e Enum[T]) ToPgx() pgtype.Text {
	if !e.set || e.null {
		return pgtype.Text{Valid: false}
	}
	return pgtype.Text{
		String: fmt.Sprint(e.value),
		Valid:  true,
	}
}

// parseEnumFromString converts a string to enum value of type T.
// Supports:
// - Protobuf enums (via protoreflect)
// - Standard Go enums (both int and string based)
// - Case-insensitive matching
func parseEnumFromString[T comparable](s string) (T, error) {
	var zero T
	tType := reflect.TypeOf(zero)

	// Handle protobuf enums (types generated by protoc)
	if protoEnum, ok := any(zero).(interface {
		Descriptor() protoreflect.EnumDescriptor
	}); ok {
		enumDesc := protoEnum.Descriptor()
		// Case-insensitive match against enum names
		for i := 0; i < enumDesc.Values().Len(); i++ {
			val := enumDesc.Values().Get(i)
			if strings.EqualFold(string(val.Name()), strings.ToUpper(s)) {
				return reflect.ValueOf(val.Number()).Interface().(T), nil
			}
		}
		return zero, fmt.Errorf("unknown proto enum value: %s", s)
	}

	// Handle standard Go enums
	switch tType.Kind() {
	case reflect.String:
		// For string-based enums (type Status string)
		return any(strings.ToUpper(s)).(T), nil

	case reflect.Int, reflect.Int32, reflect.Int64:
		// For iota-based enums (type Status int)
		// Try to parse as number first
		if num, err := strconv.ParseInt(s, 10, 64); err == nil {
			return reflect.ValueOf(num).Convert(tType).Interface().(T), nil
		}
		// Fall back to name matching
		for i := 0; i < tType.NumMethod(); i++ {
			method := tType.Method(i)
			if strings.EqualFold(method.Name, s) {
				if result := reflect.ValueOf(zero).MethodByName(method.Name).Call(nil); len(result) > 0 {
					return result[0].Interface().(T), nil
				}
			}
		}
	}

	return zero, fmt.Errorf("unsupported enum type or unknown value: %s", s)
}
